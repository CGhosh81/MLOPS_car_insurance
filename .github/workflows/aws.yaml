# name: Deploy Application Docker Image to EC2 instance

# on:
#   push:
#     branches: [main]

# jobs:
#   Continuous-Integration:
#     runs-on: ubuntu-latest

#     steps:
#       - name: Checkout
#         uses: actions/checkout@v2

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v1
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@v1

#       - name: Build, tag, and push image to Amazon ECR
#         id: build-image
#         env:
#           ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
#           ECR_REPOSITORY: ${{ secrets.ECR_REPO }}
#           IMAGE_TAG: latest
#         run: |
#           docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .  
#           docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
#           echo "::set-output name=image::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

# Continuous-Deployment:
#     # This job runs after the build job is successful
#     needs: Continuous-Integration
#     runs-on: self-hosted

#     steps:
#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v4 # Updated action
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@v2 # Updated action

#       - name: Pull, Stop, and Run Docker Image
#         env:
#           # Use the image URI passed from the build job for reliability
#           IMAGE_URI: ${{ needs.Continuous-Integration.outputs.image_uri }}
#           CONTAINER_NAME: my-app-container # A consistent name for your container
#         run: |
#           # 1. Pull the new image from ECR to ensure we have the latest version.
#           # This is the essential step that was missing.
#           docker pull "$IMAGE_URI"
          
#           # 2. Stop and remove the existing container if it's running.
#           # The '|| true' ensures the workflow doesn't fail if the container doesn't exist yet.
#           docker stop "$CONTAINER_NAME" || true
#           docker rm "$CONTAINER_NAME" || true
          
#           # 3. Run the new container with a specific name and environment variables.
#           docker run -d --name "$CONTAINER_NAME" \
#             -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
#             -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
#             -e AWS_DEFAULT_REGION="${{ secrets.AWS_DEFAULT_REGION }}" \
#             -e MONGODB_URL="${{ secrets.MONGODB_URL }}" \
#             -p 5000:5000 \
#             "$IMAGE_URI"

#   # Continuous-Deployment:
#   #   needs: Continuous-Integration
#   #   runs-on: self-hosted
#   #   steps:
#   #     - name: Checkout
#   #       uses: actions/checkout@v3

#   #     - name: Configure AWS credentials
#   #       uses: aws-actions/configure-aws-credentials@v1
#   #       with:
#   #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#   #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#   #         aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

#   #     - name: Login to Amazon ECR
#   #       id: login-ecr
#   #       uses: aws-actions/amazon-ecr-login@v1

#   #     - name: Run Docker Image to serve users
#   #       run: |
#   #        docker run -d -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" -e AWS_DEFAULT_REGION="${{ secrets.AWS_DEFAULT_REGION }}" -e MONGODB_URL="${{ secrets.MONGODB_URL }}" -p 5000:5000 "${{ steps.login-ecr.outputs.registry }}"/"${{ secrets.ECR_REPO }}":latest


# # name: Deploy Application Docker Image to EC2 instance

# # on:
# #   push:
# #     branches: [main]

# # jobs:
# #   Continuous-Integration:
# #     runs-on: ubuntu-latest
# #     # Define an output to pass the full image URI to the next job
# #     outputs:
# #       image_uri: ${{ steps.build-image.outputs.image }}

# #     steps:
# #       - name: Checkout
# #         uses: actions/checkout@v4

# #       - name: Configure AWS credentials
# #         uses: aws-actions/configure-aws-credentials@v4
# #         with:
# #           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
# #           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
# #           aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

# #       - name: Login to Amazon ECR
# #         id: login-ecr
# #         uses: aws-actions/amazon-ecr-login@v2

# #       - name: Build, tag, and push image to Amazon ECR
# #         id: build-image
# #         env:
# #           ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
# #           ECR_REPOSITORY: ${{ secrets.ECR_REPO }}
# #           IMAGE_TAG: latest
# #         run: |
# #           IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
# #           docker build -t "$IMAGE_URI" .
# #           docker push "$IMAGE_URI"
# #           # Use the recommended method to set the output for other jobs
# #           echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT

# #   Continuous-Deployment:
# #     # This job depends on the successful completion of the CI job
# #     needs: Continuous-Integration
# #     runs-on: self-hosted
# #     steps:
# #       - name: Configure AWS credentials
# #         uses: aws-actions/configure-aws-credentials@v4
# #         with:
# #           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
# #           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
# #           aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

# #       - name: Login to Amazon ECR
# #         id: login-ecr
# #         uses: aws-actions/amazon-ecr-login@v2

# #       - name: Pull, Stop, and Run Docker Image
# #         env:
# #           # Retrieve the exact image URI from the build job's output
# #           IMAGE_URI: ${{ needs.Continuous-Integration.outputs.image_uri }}
# #           CONTAINER_NAME: my-app-container # A consistent name for your container
# #         run: |
# #           # 1. Pull the new image from ECR to ensure we have the latest version
# #           echo "Pulling image: $IMAGE_URI"
# #           docker pull "$IMAGE_URI"
          
# #           # 2. Stop and remove the existing container if it's running
# #           # The '|| true' ensures the workflow doesn't fail if the container doesn't exist yet
# #           echo "Stopping and removing existing container: $CONTAINER_NAME"
# #           docker stop "$CONTAINER_NAME" || true
# #           docker rm "$CONTAINER_NAME" || true
          
# #           # 3. Run the new container with the specified name and environment variables
# #           echo "Starting new container: $CONTAINER_NAME"
# #           docker run -d --name "$CONTAINER_NAME" \
# #             -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
# #             -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
# #             -e AWS_DEFAULT_REGION="${{ secrets.AWS_DEFAULT_REGION }}" \
# #             -e MONGODB_URL="${{ secrets.MONGODB_URL }}" \
# #             -p 5000:5000 \
# #             "$IMAGE_URI"




name: Deploy Application Docker Image to EC2 instance

on:
  push:
    branches: [main]

jobs:
  # JOB 1: Build the Docker image and push it to Amazon ECR
  Continuous-Integration:
    runs-on: ubuntu-latest
    # Define an output to pass the full image URI to the next job
    outputs:
      image_uri: ${{ steps.build-image.outputs.image }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPO }}
          IMAGE_TAG: latest
        run: |
          # Build the Docker image
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          docker build -t "$IMAGE_URI" .
          
          # Push the image to ECR
          docker push "$IMAGE_URI"
          
          # Set the output for the next job using the recommended method
          echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT

  # JOB 2: Deploy the Docker image to the self-hosted runner on EC2
  Continuous-Deployment:
    # This job depends on the successful completion of the build job
    needs: Continuous-Integration
    runs-on: self-hosted

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_DEFAULT_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Pull, Stop, and Run Docker Image
        env:
          # Retrieve the exact image URI from the build job's output
          IMAGE_URI: ${{ needs.Continuous-Integration.outputs.image_uri }}
          CONTAINER_NAME: my-app-container # A consistent name for your container
        run: |
          # 1. Pull the new image from ECR to ensure we have the latest version.
          echo "Pulling latest image: $IMAGE_URI"
          docker pull "$IMAGE_URI"
          
          # 2. Stop and remove the existing container if it's running.
          # The '|| true' ensures the workflow doesn't fail if the container doesn't exist yet.
          echo "Stopping and removing existing container: $CONTAINER_NAME"
          docker stop "$CONTAINER_NAME" || true
          docker rm "$CONTAINER_NAME" || true
          
          # 3. Run the new container with a specific name and environment variables.
          echo "Starting new container: $CONTAINER_NAME"
          docker run -d --name "$CONTAINER_NAME" \
            -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -e AWS_DEFAULT_REGION="${{ secrets.AWS_DEFAULT_REGION }}" \
            -e MONGODB_URL="${{ secrets.MONGODB_URL }}" \
            -p 5000:5000 \
            "$IMAGE_URI"
